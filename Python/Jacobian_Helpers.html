<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.5">
<title>Jacobian_Helpers API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Jacobian_Helpers</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="Jacobian_Helpers.J_from_F"><code class="name flex">
<span>def <span class="ident">J_from_F</span></span>(<span>F, dt=1.0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit
def J_from_F(F, dt = 1.0):
    &#34;&#34;&#34;Helper function to calculate the Jacobian by adding up diagonals of the fake news matrix

    Args:
        F: Fake news matrix

    Returns:
        J: Jacobian matrix
    &#34;&#34;&#34;
    J = F.copy()
    for t in range(1, J.shape[0]):
        J[1:, t] = J[:-1, t - 1] + dt * F[1:, t]
    return J</code></pre>
</details>
<div class="desc"><p>Helper function to calculate the Jacobian by adding up diagonals of the fake news matrix</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>F</code></strong></dt>
<dd>Fake news matrix</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>J</code></dt>
<dd>Jacobian matrix</dd>
</dl></div>
</dd>
<dt id="Jacobian_Helpers.calc_D"><code class="name flex">
<span>def <span class="ident">calc_D</span></span>(<span>gm,<br>rho,<br>LT_c,<br>U,<br>phi,<br>LT_p,<br>T,<br>dt=1.0,<br>L_c=None,<br>dphi_da=None,<br>u_cp=None,<br>u_cz=None,<br>c_t=None,<br>price=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_D(gm, rho, LT_c, U, phi, LT_p, T, dt = 1.0, L_c = None, dphi_da = None, u_cp = None, u_cz = None, c_t = None, price = True):
    &#34;&#34;&#34;Calculates D, change in distribution from either price or aggregate shock

    Args:
        gm: Steady state distribution (either Nz x Na matrix or Nz*Nz x 1 vector)
        rho: Discount rate
        LT_c: Function for transition matrix gradient w.r.t. consumption (Nz*Na x Nz*Na matrix)
        U: u_{cc} + L_{cc}[V^{ss}] (either Nz x Na matrix or Nz*Nz x 1 vector)
        phi: Change in value from shock (varphi for price and phi for aggregate shock) (Nz*Na x T matrix)
        LT_p: Function for steady state transition matrix (mathcal{L}* in text) gradient w.r.t. price (Nz*Na x Nz*Na matrix)
        T: Number of time periods
        dt: Time step
        L_c: Steady state expectation matrix (mathcal{L} in text) gradient w.r.t. consumption (Nz*Na x Nz*Na matrix)
            If unspecified or None, use dphi_da
        dphi_da: Sum over x of Derivative of phi_t w.r.t. x (Nz*Na x T matrix)
        u_cp: Derivative of utility w.r.t. consumption and price (either Nz x Na matrix or Nz*Nz x 1 vector)
        u_cz: Derivative of utility w.r.t. consumption and aggregate shock (either Nz x Na matrix or Nz*Nz x 1 vector)
        c_t: Change in policy at time 0 from anticipated price/aggregate shock at each time s (T x 1 vector)
            If not None, use to calculate D directly from c_t
        price: True if price shock, False if aggregate shock

    Returns:
        D: Change in distribution (Nz*Na x T matrix)
        P: Change in distribution from immediate income shock (Nz*Na x 1 vector)
    &#34;&#34;&#34;

    U_inv = 1 / U.flatten()
    gm = gm.flatten()

    if price: # Distribution change from change in income due to price shock
        P = LT_p(gm)
        if u_cp is not None:
            P -= LT_c(U_inv * u_cp.flatten())
    else: # Distribution change from change in income due to aggregate shock
        P = np.zeros_like(gm)
        if u_cz is not None:
            P = -LT_c(U_inv * u_cz.flatten())

    # If change in policy available, calculate D directly
    if c_t is not None:
        D = LT_c(c_t)
        D[:, 0] += P # Add change in distribution directly from changed incomes
        return D, P

    # Solve for \cM
    if L_c is not None:
        cM = -LT_c(U_inv * gm * (L_c @ phi))
    else:
        cM = LT_c((U_inv * gm)[:,np.newaxis] * dphi_da)

    # Solve for D
    D = np.exp(-rho * dt * np.arange(T))[np.newaxis,:] * cM
    D[:, 0] += P # Add change in distribution directly from changed incomes

    return D, P</code></pre>
</details>
<div class="desc"><p>Calculates D, change in distribution from either price or aggregate shock</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gm</code></strong></dt>
<dd>Steady state distribution (either Nz x Na matrix or Nz*Nz x 1 vector)</dd>
<dt><strong><code>rho</code></strong></dt>
<dd>Discount rate</dd>
<dt><strong><code>LT_c</code></strong></dt>
<dd>Function for transition matrix gradient w.r.t. consumption (Nz<em>Na x Nz</em>Na matrix)</dd>
<dt><strong><code>U</code></strong></dt>
<dd>u_{cc} + L_{cc}[V^{ss}] (either Nz x Na matrix or Nz*Nz x 1 vector)</dd>
<dt><strong><code>phi</code></strong></dt>
<dd>Change in value from shock (varphi for price and phi for aggregate shock) (Nz*Na x T matrix)</dd>
<dt><strong><code>LT_p</code></strong></dt>
<dd>Function for steady state transition matrix (mathcal{L}<em> in text) gradient w.r.t. price (Nz</em>Na x Nz*Na matrix)</dd>
<dt><strong><code>T</code></strong></dt>
<dd>Number of time periods</dd>
<dt><strong><code>dt</code></strong></dt>
<dd>Time step</dd>
<dt><strong><code>L_c</code></strong></dt>
<dd>Steady state expectation matrix (mathcal{L} in text) gradient w.r.t. consumption (Nz<em>Na x Nz</em>Na matrix)
If unspecified or None, use dphi_da</dd>
<dt><strong><code>dphi_da</code></strong></dt>
<dd>Sum over x of Derivative of phi_t w.r.t. x (Nz*Na x T matrix)</dd>
<dt><strong><code>u_cp</code></strong></dt>
<dd>Derivative of utility w.r.t. consumption and price (either Nz x Na matrix or Nz*Nz x 1 vector)</dd>
<dt><strong><code>u_cz</code></strong></dt>
<dd>Derivative of utility w.r.t. consumption and aggregate shock (either Nz x Na matrix or Nz*Nz x 1 vector)</dd>
<dt><strong><code>c_t</code></strong></dt>
<dd>Change in policy at time 0 from anticipated price/aggregate shock at each time s (T x 1 vector)
If not None, use to calculate D directly from c_t</dd>
<dt><strong><code>price</code></strong></dt>
<dd>True if price shock, False if aggregate shock</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>D</code></dt>
<dd>Change in distribution (Nz*Na x T matrix)</dd>
<dt><code>P</code></dt>
<dd>Change in distribution from immediate income shock (Nz*Na x 1 vector)</dd>
</dl></div>
</dd>
<dt id="Jacobian_Helpers.calc_E"><code class="name flex">
<span>def <span class="ident">calc_E</span></span>(<span>E, T, ss, dt=1.0, outputs=None, iter_style='DT_loop')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_E(E, T, ss, dt = 1.0, outputs = None, iter_style = &#39;DT_loop&#39;):
    &#34;&#34;&#34;Calculates E_t = T_t E = (I + dt L)^t E, the effect on output y at time t
    from a change in the mass at gridpoint x at time 0 under steady-state policy rules

    Args:
        E: Dictionary of E_0 matrices by output giving dy/dg(x) (the effect of output y from a change in the mass at x)
        T: Number of time periods
        ss: Steady-state dictionary
        dt: Time step
        outputs: List of output variables
        iter_style: How to iterate forward in phi and E calculations
            3 options: &#39;CT_matrix&#39;, &#39;CT_loop&#39;, &#39;DT_loop&#39; where &#39;CT&#39; uses ly and DT uses Pi and &#39;matrix&#39; does a sparse matrix multiplication while &#39;loop&#39; uses a for loop with numba

    Returns:
        E_t_struct: Dictionary of E_t matrices by output
    &#34;&#34;&#34;

    if outputs is None:
        outputs = E.keys()
    E_t_struct = {output: np.zeros((T, E[output].shape[0], E[output].shape[1])) for output in outputs}

    for output in outputs:
        E_t_struct[output][0, ...] = E[output]

    # Iterate forward to get E_t
    for output in outputs:
        for t in range(T - 1):
            if iter_style == &#39;DT_loop&#39;:
                E_t_struct[output][t + 1, ...] = forward_step_transpose_1d_dt(E_t_struct[output][t, ...], ss[&#39;Pi&#39;], ss[&#39;a_ind&#39;], ss[&#39;sav_wt&#39;])
            elif iter_style == &#39;CT_loop&#39;:
                E_t_struct[output][t + 1, ...] = forward_step_transpose_1d(E_t_struct[output][t, ...], ss[&#39;ly&#39;], ss[&#39;a_ind&#39;], ss[&#39;S_npy&#39;], dt = dt)
            else:
                E_t_struct[output][t + 1, ...] = forward_step_matrix(E_t_struct[output][t, ...], ss[&#39;ly&#39;], ss[&#39;S_stable&#39;], dt = dt)

        E_t_struct[output] = E_t_struct[output]

    return E_t_struct</code></pre>
</details>
<div class="desc"><p>Calculates E_t = T_t E = (I + dt L)^t E, the effect on output y at time t
from a change in the mass at gridpoint x at time 0 under steady-state policy rules</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>E</code></strong></dt>
<dd>Dictionary of E_0 matrices by output giving dy/dg(x) (the effect of output y from a change in the mass at x)</dd>
<dt><strong><code>T</code></strong></dt>
<dd>Number of time periods</dd>
<dt><strong><code>ss</code></strong></dt>
<dd>Steady-state dictionary</dd>
<dt><strong><code>dt</code></strong></dt>
<dd>Time step</dd>
<dt><strong><code>outputs</code></strong></dt>
<dd>List of output variables</dd>
<dt><strong><code>iter_style</code></strong></dt>
<dd>How to iterate forward in phi and E calculations
3 options: 'CT_matrix', 'CT_loop', 'DT_loop' where 'CT' uses ly and DT uses Pi and 'matrix' does a sparse matrix multiplication while 'loop' uses a for loop with numba</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>E_t_struct</code></dt>
<dd>Dictionary of E_t matrices by output</dd>
</dl></div>
</dd>
<dt id="Jacobian_Helpers.calc_F"><code class="name flex">
<span>def <span class="ident">calc_F</span></span>(<span>E, D, outputs, T, c_t={})</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_F(E, D, outputs, T, c_t = {}):
    &#34;&#34;&#34;Calculates the fake news matrix for each output

    Args:
        E: Dictionary of E matrices (response of output to distribution change) by output where E_t = T_t E = (I + dt L)^t E
        D: Array giving the change in the distribution from shock
        outputs: List of output variables
        T: Number of time periods
        c_t: Dictionary for effect at time 0 for control variables

    Returns:
        F: Dictionary of fake news matrices by output
    &#34;&#34;&#34;

    controls = c_t.keys()
    F = {o: {} for o in outputs}
    for output in outputs:
        F[output] = np.zeros((T, T))
        if output in controls:
            F[output][0, :] = c_t[output]
        F[output][1:, :] = (E[output][:T - 1, ...].reshape(T - 1, -1) @ D)

    return F</code></pre>
</details>
<div class="desc"><p>Calculates the fake news matrix for each output</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>E</code></strong></dt>
<dd>Dictionary of E matrices (response of output to distribution change) by output where E_t = T_t E = (I + dt L)^t E</dd>
<dt><strong><code>D</code></strong></dt>
<dd>Array giving the change in the distribution from shock</dd>
<dt><strong><code>outputs</code></strong></dt>
<dd>List of output variables</dd>
<dt><strong><code>T</code></strong></dt>
<dd>Number of time periods</dd>
<dt><strong><code>c_t</code></strong></dt>
<dd>Dictionary for effect at time 0 for control variables</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>F</code></dt>
<dd>Dictionary of fake news matrices by output</dd>
</dl></div>
</dd>
<dt id="Jacobian_Helpers.calc_J"><code class="name flex">
<span>def <span class="ident">calc_J</span></span>(<span>F, outputs, dt=1.0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_J(F, outputs, dt = 1.0):
    &#34;&#34;&#34;Calculates the Jacobian for each output by adding up diagonals of the fake news matrix

    Args:
        F: A dictionary of fake news matrices.
        outputs: A list of output variables.

    Returns:
        J: A dictionary of Jacobian matrices.
    &#34;&#34;&#34;
    J = {}
    for output in outputs:
        J[output] = J_from_F(F[output], dt = dt) * dt

    return J</code></pre>
</details>
<div class="desc"><p>Calculates the Jacobian for each output by adding up diagonals of the fake news matrix</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>F</code></strong></dt>
<dd>A dictionary of fake news matrices.</dd>
<dt><strong><code>outputs</code></strong></dt>
<dd>A list of output variables.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>J</code></dt>
<dd>A dictionary of Jacobian matrices.</dd>
</dl></div>
</dd>
<dt id="Jacobian_Helpers.calc_U"><code class="name flex">
<span>def <span class="ident">calc_U</span></span>(<span>u_cc, L_cc=None, Vss=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_U(u_cc, L_cc = None, Vss = None):
    &#34;&#34;&#34;Calculates change in aggregate consumption at time 0 from anticipated price/aggregate shock at each time s

    Args:
        u_cc: Second derivative of utility with respect to consumption
        L_cc: Second derivative of expectation operator with respect to consumption (assumed to be 0 if None or unspecified)
        Vss: Steady state value function (Nz x Na matrix or Nz*Na x 1 vector). Must be specified if L_cc is not None

    Returns:
        U: u_{cc} + L_{cc}[V^{ss}] (either Nz x Na matrix or Nz*Nz x 1 vector)
    &#34;&#34;&#34;
    if L_cc is None:
        return u_cc
    
    return u_cc + L_cc @ Vss</code></pre>
</details>
<div class="desc"><p>Calculates change in aggregate consumption at time 0 from anticipated price/aggregate shock at each time s</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>u_cc</code></strong></dt>
<dd>Second derivative of utility with respect to consumption</dd>
<dt><strong><code>L_cc</code></strong></dt>
<dd>Second derivative of expectation operator with respect to consumption (assumed to be 0 if None or unspecified)</dd>
<dt><strong><code>Vss</code></strong></dt>
<dd>Steady state value function (Nz x Na matrix or Nz*Na x 1 vector). Must be specified if L_cc is not None</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>U</code></dt>
<dd>u_{cc} + L_{cc}[V^{ss}] (either Nz x Na matrix or Nz*Nz x 1 vector)</dd>
</dl></div>
</dd>
<dt id="Jacobian_Helpers.calc_dphi_dx"><code class="name flex">
<span>def <span class="ident">calc_dphi_dx</span></span>(<span>phi_t, DA_mat, endog_states)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_dphi_dx(phi_t, DA_mat, endog_states):
    &#34;&#34;&#34;Calculates dphi/dx for each x in endog_states

    Args:
        phi_t: Change in value for agents at x at time t from price/aggregate shock (Nz*Na x T matrix)
        DA_mat: Dictionary of derivative matrices w.r.t. x for numerical differentiation
        endog_states: List of endogenous states

    Returns:
        dphi_da: Derivative of phi_t w.r.t. x where given derivative matrix determines x (Nz*Na x T matrix)
    &#34;&#34;&#34;

    dphi_da = {}
    for state in endog_states:
        dphi_da[state] = DA_mat[state] @ phi_t
    
    return dphi_da</code></pre>
</details>
<div class="desc"><p>Calculates dphi/dx for each x in endog_states</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>phi_t</code></strong></dt>
<dd>Change in value for agents at x at time t from price/aggregate shock (Nz*Na x T matrix)</dd>
<dt><strong><code>DA_mat</code></strong></dt>
<dd>Dictionary of derivative matrices w.r.t. x for numerical differentiation</dd>
<dt><strong><code>endog_states</code></strong></dt>
<dd>List of endogenous states</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dphi_da</code></dt>
<dd>Derivative of phi_t w.r.t. x where given derivative matrix determines x (Nz*Na x T matrix)</dd>
</dl></div>
</dd>
<dt id="Jacobian_Helpers.calc_irfs"><code class="name flex">
<span>def <span class="ident">calc_irfs</span></span>(<span>J, shock, zeta, prices)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_irfs(J, shock, zeta, prices):
    &#34;&#34;&#34;Calculates the impulse responses using partial equilibrium price Jacobians.
    Need Jacobian of each price w.r.t. all prices (including itself)

    Args:
        J: Dictionary of Jacobian matrices. Must include Jacobians of each price to each price.
        shock: Vector of shock (of length T)
        zeta: Dictionary where each price gives a number for how the shock affects each price (dp/dz(0,g^{ss})). 0 if t not equal to s
        prices: List of prices
    Returns:
        irfs: A dictionary of IRFs of each price (which can then be used to get IRFs of other variables)
    &#34;&#34;&#34;
    dp_vec = np.zeros(len(prices) * len(shock))
    for price in prices:
        dp_vec = np.concatenate((dp_vec, zeta[price] * shock))

    # Create block matrix that will be inverted
    full_jac = []

    # Loop through each row
    for j in range(len(prices)):
        # List to hold the blocks for the current row
        row_blocks = []
        # Loop through each column
        for i in range(len(prices)):
            # Append the current block to the row
            row_blocks.append(J[prices[i]][prices[j]])
        # Append the current row to the big matrix
        full_jac.append(row_blocks)

    # Combine list into a matrix
    full_jac = np.block(full_jac)

    # Solve given system of equations
    solved_vec = solve(np.eye(len(full_jac)) - full_jac, dp_vec)

    # Convert into dictionary
    irfs = {}
    for i, price in enumerate(prices):
        irfs[price] = solved_vec[i * len(shock):(i + 1) * len(shock)]

    return irfs</code></pre>
</details>
<div class="desc"><p>Calculates the impulse responses using partial equilibrium price Jacobians.
Need Jacobian of each price w.r.t. all prices (including itself)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>J</code></strong></dt>
<dd>Dictionary of Jacobian matrices. Must include Jacobians of each price to each price.</dd>
<dt><strong><code>shock</code></strong></dt>
<dd>Vector of shock (of length T)</dd>
<dt><strong><code>zeta</code></strong></dt>
<dd>Dictionary where each price gives a number for how the shock affects each price (dp/dz(0,g^{ss})). 0 if t not equal to s</dd>
<dt><strong><code>prices</code></strong></dt>
<dd>List of prices</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>irfs</code></dt>
<dd>A dictionary of IRFs of each price (which can then be used to get IRFs of other variables)</dd>
</dl></div>
</dd>
<dt id="Jacobian_Helpers.calc_phi"><code class="name flex">
<span>def <span class="ident">calc_phi</span></span>(<span>ss,<br>n,<br>T,<br>dt=1.0,<br>L_p=None,<br>Vss=None,<br>phi0=None,<br>u_p=0,<br>C_p=0,<br>C_V=0,<br>C_dV=0,<br>price=True,<br>iter_style='DT_loop')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_phi(ss, n, T, dt = 1.0, L_p = None, Vss = None, phi0 = None, u_p = 0, C_p = 0, C_V = 0, C_dV = 0, price = True, iter_style = &#39;DT_loop&#39;):
    &#34;&#34;&#34;Calculates varphi for price or phi for aggregate shock, effect of shock on value

    Args:
        ss: Steady state dictionary
        n: Numerical parameters dictionary
        T: Number of time periods
        dt: Time step
        L_p: Steady state expectation matrix (mathcal{L} in text) gradient w.r.t. price (Nz*Na x Nz*Na matrix)
        Vss: Steady state value function (Nz x Na matrix or Nz*Na x 1 vector)
        phi0: Initial change in value from shock (Nz*Na x 1 vector)
            Note that if phi0 is None, L_p @ Vss is used
        u_p: Derivative of utility w.r.t. price or aggregate shock (in that case, this is u_z) (either number or Nz*Na x 1 vector)
        C_p: Derivative of constraint w.r.t. price (either float or Nz*Na x 1 vector for constrained indices only)
        C_V: Derivative of constraint w.r.t. value (either float or Nz*Na x 1 vector for constrained indices only)
        C_dV: Derivative of constraint w.r.t. change in value (either float or Nz*Na x 1 vector for constrained indices only)
        price: Whether shock is to price or aggregate shock
        iter_style: How to iterate forward in phi and E calculations
            3 options: &#39;CT_matrix&#39;, &#39;CT_loop&#39;, &#39;DT_loop&#39; where &#39;CT&#39; uses ly and DT uses Pi and &#39;matrix&#39; does a sparse matrix multiplication while &#39;loop&#39; uses a for loop with numba
        
    Returns:
        phi_t: Change in value for agents at x at time t from price/aggregate shock (Nz*Na x T matrix)
    &#34;&#34;&#34;

    # Initialize phi
    if price and phi0 is None:
        phi0 = L_p @ Vss.flatten()
    elif phi0 is None:
        phi0 = np.zeros_like(Vss)

    phi0 += u_p # Add u_p or u_z to phi0

    # Adjust for constraints
    phi0 = phi_constraints(phi0, ss[&#39;consted&#39;], n[&#39;daa&#39;], C_p, C_V, C_dV)

    # Solve for phi_t by iterating forward
    phi_t          = np.zeros((n[&#39;Nz&#39;], n[&#39;Na&#39;], T))
    phi_t[:, :, 0] = phi0

    for t in range(T - 1):
        if iter_style == &#39;DT_loop&#39;:
            phi_t[:, :, t + 1] = forward_step_transpose_1d_dt(np.ascontiguousarray(phi_t[:, :, t]), n[&#39;Pi&#39;], ss[&#39;a_ind&#39;], ss[&#39;sav_wt&#39;])
        elif iter_style == &#39;CT_loop&#39;:
            phi_t[:, :, t + 1] = forward_step_transpose_1d(np.ascontiguousarray(phi_t[:, :, t]), n[&#39;ly&#39;], ss[&#39;a_ind&#39;], ss[&#39;S_npy&#39;], dt = dt)
        else:
            phi_t[:, :, t + 1] = forward_step_matrix(np.ascontiguousarray(phi_t[:, :, t]), n[&#39;ly&#39;], ss[&#39;S_stable&#39;], dt = dt)
        
        phi_t[:, :, t + 1] = phi_constraints(phi_t[:, :, t + 1], ss[&#39;consted&#39;], n[&#39;daa&#39;], 0, C_V, C_dV) # adjust constrained agents&#39; value

    # Reshape into vector for later use
    phi_t = phi_t.reshape((n[&#39;Ntot&#39;], T))

    return phi_t</code></pre>
</details>
<div class="desc"><p>Calculates varphi for price or phi for aggregate shock, effect of shock on value</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ss</code></strong></dt>
<dd>Steady state dictionary</dd>
<dt><strong><code>n</code></strong></dt>
<dd>Numerical parameters dictionary</dd>
<dt><strong><code>T</code></strong></dt>
<dd>Number of time periods</dd>
<dt><strong><code>dt</code></strong></dt>
<dd>Time step</dd>
<dt><strong><code>L_p</code></strong></dt>
<dd>Steady state expectation matrix (mathcal{L} in text) gradient w.r.t. price (Nz<em>Na x Nz</em>Na matrix)</dd>
<dt><strong><code>Vss</code></strong></dt>
<dd>Steady state value function (Nz x Na matrix or Nz*Na x 1 vector)</dd>
<dt><strong><code>phi0</code></strong></dt>
<dd>Initial change in value from shock (Nz*Na x 1 vector)
Note that if phi0 is None, L_p @ Vss is used</dd>
<dt><strong><code>u_p</code></strong></dt>
<dd>Derivative of utility w.r.t. price or aggregate shock (in that case, this is u_z) (either number or Nz*Na x 1 vector)</dd>
<dt><strong><code>C_p</code></strong></dt>
<dd>Derivative of constraint w.r.t. price (either float or Nz*Na x 1 vector for constrained indices only)</dd>
<dt><strong><code>C_V</code></strong></dt>
<dd>Derivative of constraint w.r.t. value (either float or Nz*Na x 1 vector for constrained indices only)</dd>
<dt><strong><code>C_dV</code></strong></dt>
<dd>Derivative of constraint w.r.t. change in value (either float or Nz*Na x 1 vector for constrained indices only)</dd>
<dt><strong><code>price</code></strong></dt>
<dd>Whether shock is to price or aggregate shock</dd>
<dt><strong><code>iter_style</code></strong></dt>
<dd>How to iterate forward in phi and E calculations
3 options: 'CT_matrix', 'CT_loop', 'DT_loop' where 'CT' uses ly and DT uses Pi and 'matrix' does a sparse matrix multiplication while 'loop' uses a for loop with numba</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>phi_t</code></dt>
<dd>Change in value for agents at x at time t from price/aggregate shock (Nz*Na x T matrix)</dd>
</dl></div>
</dd>
<dt id="Jacobian_Helpers.calc_phi_HJB"><code class="name flex">
<span>def <span class="ident">calc_phi_HJB</span></span>(<span>lhs_mat, n, T, L_p=None, Vss=None, phi0=None, u_p=0, price=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_phi_HJB(lhs_mat, n, T, L_p = None, Vss = None, phi0 = None, u_p = 0, price = True):
    &#34;&#34;&#34;Calculates varphi for price or phi for aggregate shock, effect of shock on value,
        using a matrix for transitioning forward instead of the function.
    Note: Not used in the scripts.

    Args:
        lhs_mat: Matrix to iterate phi_t forward (faster if sparse)
        n: Numerical parameters dictionary
        T: Number of time periods
        L_p: Steady state expectation matrix (mathcal{L} in text) gradient w.r.t. price (Nz*Na x Nz*Na matrix)
        Vss: Steady state value function (Nz x Na matrix or Nz*Na x 1 vector)
        phi0: Initial change in value from shock (Nz*Na x 1 vector)
            Note that if phi0 is None, L_p @ Vss is used
        u_p: Derivative of utility w.r.t. price or aggregate shock (in that case, this is u_z) (either number or Nz*Na x 1 vector)
        price: Whether shock is to price or aggregate shock

    Returns:
        phi_t: Change in value for agents at x at time t from price/aggregate shock (Nz*Na x T matrix)
    &#34;&#34;&#34;
    # Initialize phi
    if price and phi0 is None:
        phi0 = L_p @ Vss.flatten()
    elif phi0 is None:
        phi0 = np.zeros_like(Vss)

    phi0 += u_p # Add u_p or u_z to phi0

    # Solve for phi_t by iterating forward
    phi_t = np.zeros((n[&#39;Ntot&#39;], T))
    phi_t[:,0] = phi0

    # Iterate forward
    for t in np.arange(1,T):
        phi_t[:,t] = lhs_mat @ phi_t[:,t-1]

    return phi_t</code></pre>
</details>
<div class="desc"><p>Calculates varphi for price or phi for aggregate shock, effect of shock on value,
using a matrix for transitioning forward instead of the function.
Note: Not used in the scripts.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>lhs_mat</code></strong></dt>
<dd>Matrix to iterate phi_t forward (faster if sparse)</dd>
<dt><strong><code>n</code></strong></dt>
<dd>Numerical parameters dictionary</dd>
<dt><strong><code>T</code></strong></dt>
<dd>Number of time periods</dd>
<dt><strong><code>L_p</code></strong></dt>
<dd>Steady state expectation matrix (mathcal{L} in text) gradient w.r.t. price (Nz<em>Na x Nz</em>Na matrix)</dd>
<dt><strong><code>Vss</code></strong></dt>
<dd>Steady state value function (Nz x Na matrix or Nz*Na x 1 vector)</dd>
<dt><strong><code>phi0</code></strong></dt>
<dd>Initial change in value from shock (Nz*Na x 1 vector)
Note that if phi0 is None, L_p @ Vss is used</dd>
<dt><strong><code>u_p</code></strong></dt>
<dd>Derivative of utility w.r.t. price or aggregate shock (in that case, this is u_z) (either number or Nz*Na x 1 vector)</dd>
<dt><strong><code>price</code></strong></dt>
<dd>Whether shock is to price or aggregate shock</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>phi_t</code></dt>
<dd>Change in value for agents at x at time t from price/aggregate shock (Nz*Na x T matrix)</dd>
</dl></div>
</dd>
<dt id="Jacobian_Helpers.calc_policy_fn"><code class="name flex">
<span>def <span class="ident">calc_policy_fn</span></span>(<span>U, T, rho, gm, dt=1.0, u_cp=None, u_cz=None, dphi_da=None, L_c=None, phi_t=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_policy_fn(U, T, rho, gm, dt = 1.0, u_cp = None, u_cz = None, dphi_da = None, L_c = None, phi_t = None):
    &#34;&#34;&#34;Calculates change in consumption at time 0 for each agent from anticipated price/aggregate shock at each time s

    Args:
        U: u_{cc} + L_{cc}[V^{ss}] (either Nz x Na matrix or Nz*Na x 1 vector)
        T: Number of time periods
        rho: Discount rate
        gm: Steady state distribution (either Nz x Na matrix or Nz*Na x 1 vector, same dimensions as U)
        dt: Time step
        u_cp: Derivative of utility w.r.t. consumption and price (either Nz x Na matrix or Nz*Nz x 1 vector)
            Assumed to be 0 if None or unspecified
        u_cz: Derivative of utility w.r.t. consumption and aggregate shock (either Nz x Na matrix or Nz x 1 vector)
            Assumed to be 0 if None or unspecified
        dphi_da: Sum over endogenous states x of Derivative of phi_t w.r.t. x (Nz*Na x T matrix)
            If unspecified or None, use L_c
        L_c: Steady state expectation matrix (mathcal{L} in text) gradient w.r.t. consumption (Nz*Na x Nz*Na matrix)
            If unspecified or None, use dphi_da (so assumed to be -sum_i d/da in that case)
        phi_t: Change in value from shock (varphi for price and phi for aggregate shock) (Nz*Na x T matrix)

    Returns:
        c_t: Change in consumption at time 0 from anticipated price/aggregate shock at each time t (T x 1 vector)
    &#34;&#34;&#34;

    rho_T  = np.expand_dims(np.exp(-rho * np.arange(T) * dt), axis=0)
    gU_inv = (gm / U).ravel()[:, np.newaxis] # U^{-1} g(x)

    # if dphi_da is available, assume L_c(x)[\psi_t] = \int_s e^{-\rho s} dphi/da_s(x) p-hat_s ds
    if dphi_da is None and L_c is not None and phi_t is not None:
        dphi_da = -L_c @ phi_t
    elif dphi_da is not None:
        RuntimeError(&#34;Need to provide either dphi_da or (L_c and phi_t)&#34;)

    # calculate c_t(x) = e^{-\rho t} dphi/da_t(x) p-hat_t
    c_t = ne.evaluate(&#39;dphi_da * gU_inv * rho_T&#39;)

    if u_cp is not None:
        c_t[:, 0] -= u_cp.flatten() * gU_inv    
    if u_cz is not None:
        c_t[:, 0] -= u_cz.flatten() * gU_inv

    return c_t</code></pre>
</details>
<div class="desc"><p>Calculates change in consumption at time 0 for each agent from anticipated price/aggregate shock at each time s</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>U</code></strong></dt>
<dd>u_{cc} + L_{cc}[V^{ss}] (either Nz x Na matrix or Nz*Na x 1 vector)</dd>
<dt><strong><code>T</code></strong></dt>
<dd>Number of time periods</dd>
<dt><strong><code>rho</code></strong></dt>
<dd>Discount rate</dd>
<dt><strong><code>gm</code></strong></dt>
<dd>Steady state distribution (either Nz x Na matrix or Nz*Na x 1 vector, same dimensions as U)</dd>
<dt><strong><code>dt</code></strong></dt>
<dd>Time step</dd>
<dt><strong><code>u_cp</code></strong></dt>
<dd>Derivative of utility w.r.t. consumption and price (either Nz x Na matrix or Nz*Nz x 1 vector)
Assumed to be 0 if None or unspecified</dd>
<dt><strong><code>u_cz</code></strong></dt>
<dd>Derivative of utility w.r.t. consumption and aggregate shock (either Nz x Na matrix or Nz x 1 vector)
Assumed to be 0 if None or unspecified</dd>
<dt><strong><code>dphi_da</code></strong></dt>
<dd>Sum over endogenous states x of Derivative of phi_t w.r.t. x (Nz*Na x T matrix)
If unspecified or None, use L_c</dd>
<dt><strong><code>L_c</code></strong></dt>
<dd>Steady state expectation matrix (mathcal{L} in text) gradient w.r.t. consumption (Nz<em>Na x Nz</em>Na matrix)
If unspecified or None, use dphi_da (so assumed to be -sum_i d/da in that case)</dd>
<dt><strong><code>phi_t</code></strong></dt>
<dd>Change in value from shock (varphi for price and phi for aggregate shock) (Nz*Na x T matrix)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>c_t</code></dt>
<dd>Change in consumption at time 0 from anticipated price/aggregate shock at each time t (T x 1 vector)</dd>
</dl></div>
</dd>
<dt id="Jacobian_Helpers.calc_policy_fn_sum"><code class="name flex">
<span>def <span class="ident">calc_policy_fn_sum</span></span>(<span>U, T, rho, gm, dt=1.0, u_cp=None, u_cz=None, dphi_da=None, L_c=None, phi_t=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_policy_fn_sum(U, T, rho, gm, dt = 1.0, u_cp = None, u_cz = None, dphi_da = None, L_c = None, phi_t = None):
    &#34;&#34;&#34;Calculates change in aggregate consumption at time 0 from anticipated price/aggregate shock at each time s

    Args:
        U: u_{cc} + L_{cc}[V^{ss}] (either Nz x Na matrix or Nz*Nz x 1 vector)
        T: Number of time periods
        rho: Discount rate
        gm: Steady state distribution (either Nz x Na matrix or Nz*Nz x 1 vector)
        dt: Time step
        u_cp: Derivative of utility w.r.t. consumption and price (either Nz x Na matrix or Nz*Nz x 1 vector)
            Assumed to be 0 if None or unspecified
        u_cz: Derivative of utility w.r.t. consumption and aggregate shock (either Nz x Na matrix or Nz x 1 vector)
            Assumed to be 0 if None or unspecified
        dphi_da: Sum over endogenous states x of Derivative of phi_t w.r.t. x (Nz*Na x T matrix)
            If unspecified or None, use L_c
        L_c: Steady state expectation matrix (mathcal{L} in text) gradient w.r.t. consumption (Nz*Na x Nz*Na matrix)
            If unspecified or None, use dphi_da (so assumed to be -sum_i d/da in that case)
        phi_t: Change in value from shock (varphi for price and phi for aggregate shock) (Nz*Na x T matrix)

    Returns:
        c_t: Change in consumption at time 0 from anticipated price/aggregate shock at each time t (T x 1 vector)
    &#34;&#34;&#34;

    U_inv  = 1 / U.flatten() # U^{-1}
    rho_T  = np.exp(-rho * np.arange(T) * dt) # discounting future
    gm     = gm.flatten()    # g(x)

    # if dphi_da is available, assume L_c(x)[\psi_t] = \int_s e^{-\rho s} dphi/da_s(x) p-hat_s ds
    if dphi_da is not None:
        c_t = dphi_da.T @ (U_inv * gm) * rho_T
    elif L_c is not None and phi_t is not None:
        c_t = ((L_c @ phi_t).T @ (-U_inv * gm)) * rho_T
    else:
        RuntimeError(&#34;Need to provide either dphi_da or (L_c and phi_t)&#34;)

    if u_cp is not None:
        c_t[0] -= np.sum(u_cp.flatten() * gm * U_inv)
    
    if u_cz is not None:
        c_t[0] -= np.sum(u_cz.flatten() * gm * U_inv)

    return c_t</code></pre>
</details>
<div class="desc"><p>Calculates change in aggregate consumption at time 0 from anticipated price/aggregate shock at each time s</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>U</code></strong></dt>
<dd>u_{cc} + L_{cc}[V^{ss}] (either Nz x Na matrix or Nz*Nz x 1 vector)</dd>
<dt><strong><code>T</code></strong></dt>
<dd>Number of time periods</dd>
<dt><strong><code>rho</code></strong></dt>
<dd>Discount rate</dd>
<dt><strong><code>gm</code></strong></dt>
<dd>Steady state distribution (either Nz x Na matrix or Nz*Nz x 1 vector)</dd>
<dt><strong><code>dt</code></strong></dt>
<dd>Time step</dd>
<dt><strong><code>u_cp</code></strong></dt>
<dd>Derivative of utility w.r.t. consumption and price (either Nz x Na matrix or Nz*Nz x 1 vector)
Assumed to be 0 if None or unspecified</dd>
<dt><strong><code>u_cz</code></strong></dt>
<dd>Derivative of utility w.r.t. consumption and aggregate shock (either Nz x Na matrix or Nz x 1 vector)
Assumed to be 0 if None or unspecified</dd>
<dt><strong><code>dphi_da</code></strong></dt>
<dd>Sum over endogenous states x of Derivative of phi_t w.r.t. x (Nz*Na x T matrix)
If unspecified or None, use L_c</dd>
<dt><strong><code>L_c</code></strong></dt>
<dd>Steady state expectation matrix (mathcal{L} in text) gradient w.r.t. consumption (Nz<em>Na x Nz</em>Na matrix)
If unspecified or None, use dphi_da (so assumed to be -sum_i d/da in that case)</dd>
<dt><strong><code>phi_t</code></strong></dt>
<dd>Change in value from shock (varphi for price and phi for aggregate shock) (Nz*Na x T matrix)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>c_t</code></dt>
<dd>Change in consumption at time 0 from anticipated price/aggregate shock at each time t (T x 1 vector)</dd>
</dl></div>
</dd>
<dt id="Jacobian_Helpers.check_if_zero"><code class="name flex">
<span>def <span class="ident">check_if_zero</span></span>(<span>C_V)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_if_zero(C_V):
    &#34;&#34;&#34;Checks if given input is zero and can be applied both to scalar or array&#34;&#34;&#34;
    if np.isscalar(C_V):
        # C_V is a number
        return C_V == 0
    else:
        # C_V is a matrix
        return np.all(C_V == 0)</code></pre>
</details>
<div class="desc"><p>Checks if given input is zero and can be applied both to scalar or array</p></div>
</dd>
<dt id="Jacobian_Helpers.forward_step_matrix"><code class="name flex">
<span>def <span class="ident">forward_step_matrix</span></span>(<span>D, ly, S_stable, dt=1.0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def forward_step_matrix(D, ly, S_stable, dt = 1.0):
    &#34;&#34;&#34;Transpose of distribution iteration with sparse matrix multiplication

    Args:
        D: Array to be iterated on (Nz x Na array)
        ly: Change in exogenous state transition matrix (Nz x Nz matrix). Rows sum to 0
        S_stable: Change in endogenous state transition matrix (Nz*Na x Nz*Na matrix). Rows sum to 0
        dt: Time step
        
    Returns:
        Dnew: Array after iterating once as in continuous time (Nz x Na array)
    &#34;&#34;&#34;
    Nz, Na = D.shape
    return D + dt * (ly @ D + (S_stable @ D.ravel()).reshape(Nz, Na))</code></pre>
</details>
<div class="desc"><p>Transpose of distribution iteration with sparse matrix multiplication</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>D</code></strong></dt>
<dd>Array to be iterated on (Nz x Na array)</dd>
<dt><strong><code>ly</code></strong></dt>
<dd>Change in exogenous state transition matrix (Nz x Nz matrix). Rows sum to 0</dd>
<dt><strong><code>S_stable</code></strong></dt>
<dd>Change in endogenous state transition matrix (Nz<em>Na x Nz</em>Na matrix). Rows sum to 0</dd>
<dt><strong><code>dt</code></strong></dt>
<dd>Time step</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dnew</code></dt>
<dd>Array after iterating once as in continuous time (Nz x Na array)</dd>
</dl></div>
</dd>
<dt id="Jacobian_Helpers.forward_step_transpose_1d"><code class="name flex">
<span>def <span class="ident">forward_step_transpose_1d</span></span>(<span>D, ly, x_i, S_npy, dt=1.0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit
def forward_step_transpose_1d(D, ly, x_i, S_npy, dt = 1.0):
    &#34;&#34;&#34;Transpose of distribution iteration with ly = Pi - Id

    Args:
        D: Array to be iterated on (Nz x Na array)
        ly: Change in exogenous state transition matrix (Nz x Nz matrix). Rows sum to 0
        x_i: Index in endogenous state space of where agents are moving to at each gridpoint (Nz x Na array)
        S_npy: Nz*Na x 3 array of the 3 probabilities of moving to x_i, x_i + 1, and i where i is current index at each gridpoint
            Rows sum to 0 since it accounts for moving away from i
        dt: Time step
        
    Returns:
        Dnew: Array after iterating once as in continuous time (Ne x Na array)
    &#34;&#34;&#34;
    # add value from where agents are moving to via endogenous policy, adjusted for dt
    Nz, Na = D.shape
    Dnew = np.zeros_like(D)
    for iz in range(Nz):
        for ix in range(Na):
            i = iz * Na + ix
            a_left = x_i[iz, ix]
            Dnew[iz, ix] = S_npy[i, 0] * D[iz, a_left] + S_npy[i, 1] * D[iz, a_left + 1] + S_npy[i, 2] * D[iz, ix]

    return D + dt * (ly @ D + Dnew) # update using exogenous and endogenous transition</code></pre>
</details>
<div class="desc"><p>Transpose of distribution iteration with ly = Pi - Id</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>D</code></strong></dt>
<dd>Array to be iterated on (Nz x Na array)</dd>
<dt><strong><code>ly</code></strong></dt>
<dd>Change in exogenous state transition matrix (Nz x Nz matrix). Rows sum to 0</dd>
<dt><strong><code>x_i</code></strong></dt>
<dd>Index in endogenous state space of where agents are moving to at each gridpoint (Nz x Na array)</dd>
<dt><strong><code>S_npy</code></strong></dt>
<dd>Nz*Na x 3 array of the 3 probabilities of moving to x_i, x_i + 1, and i where i is current index at each gridpoint
Rows sum to 0 since it accounts for moving away from i</dd>
<dt><strong><code>dt</code></strong></dt>
<dd>Time step</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dnew</code></dt>
<dd>Array after iterating once as in continuous time (Ne x Na array)</dd>
</dl></div>
</dd>
<dt id="Jacobian_Helpers.forward_step_transpose_1d_dt"><code class="name flex">
<span>def <span class="ident">forward_step_transpose_1d_dt</span></span>(<span>D, Pi, x_i, x_pi)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit
def forward_step_transpose_1d_dt(D, Pi, x_i, x_pi):
    &#34;&#34;&#34;Transpose of distribution iteration with Pi instead of ly = Pi - Id

    Args:
        D: Array to be iterated on (Nz x Na array)
        Pi: Exogenous state transition matrix (Nz x Nz matrix). Rows sum to 1 with non-negative elements
        x_i: Index in endogenous state space of where agents are moving to at each gridpoint (Nz x Na array)
        x_pi: Probability of moving to x_i at each gridpoint (for interpolation) at each gridpoint (Nz x Na array)
            Implies 1-x_pi is probability of moving to x_i + 1
        
    Returns:
        Dnew: Array after iterating once (Nz x Na array)
    &#34;&#34;&#34;
    # first update using exogenous transition matrix
    D = Pi @ D

    # then update using (transpose) endogenous policy
    Nz, nX = D.shape
    Dnew = np.zeros_like(D)
    for iz in range(Nz):
        for ix in range(nX):
            i = x_i[iz, ix]
            pi = x_pi[iz, ix]
            # add value from where agents are moving to, adjusted for dt
            Dnew[iz, ix] = pi * D[iz, i] + (1 - pi) * D[iz, i + 1]
    return Dnew</code></pre>
</details>
<div class="desc"><p>Transpose of distribution iteration with Pi instead of ly = Pi - Id</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>D</code></strong></dt>
<dd>Array to be iterated on (Nz x Na array)</dd>
<dt><strong><code>Pi</code></strong></dt>
<dd>Exogenous state transition matrix (Nz x Nz matrix). Rows sum to 1 with non-negative elements</dd>
<dt><strong><code>x_i</code></strong></dt>
<dd>Index in endogenous state space of where agents are moving to at each gridpoint (Nz x Na array)</dd>
<dt><strong><code>x_pi</code></strong></dt>
<dd>Probability of moving to x_i at each gridpoint (for interpolation) at each gridpoint (Nz x Na array)
Implies 1-x_pi is probability of moving to x_i + 1</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dnew</code></dt>
<dd>Array after iterating once (Nz x Na array)</dd>
</dl></div>
</dd>
<dt id="Jacobian_Helpers.phi_constraints"><code class="name flex">
<span>def <span class="ident">phi_constraints</span></span>(<span>phi_t, consted, daa, C_p=0, C_V=0, C_dV=0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def phi_constraints(phi_t, consted, daa, C_p = 0, C_V = 0, C_dV = 0):
    &#34;&#34;&#34;Apply the constraints in calculating phi_t

    Args:
        phi_t: Change in value for agents at x at time t from price/aggregate shock (Nz*Na x T matrix)
        consted: Boolean array indicating indices of agents that are constrained
        C_p: Derivative of constraint w.r.t. price (either float or Nz*Na x 1 vector for constrained indices only)
        C_V: Derivative of constraint w.r.t. value (either float or Nz*Na x 1 vector for constrained indices only)
        C_dV: Derivative of constraint w.r.t. change in value (either float or Nz*Na x 1 vector for constrained indices only)

    Returns:
        phi_t (after adjusting the constrained indices)
    &#34;&#34;&#34;

    if check_if_zero(C_V) and not check_if_zero(C_dV):
        phi_t[consted] = phi_t[:, 1:][consted[:, :-1]] + daa[consted] * C_p / C_dV
    elif check_if_zero(C_dV) and not check_if_zero(C_V):
        phi_t[consted] = -C_p / C_V
    elif not (check_if_zero(C_V) or check_if_zero(C_dV)):
        phi_t[consted] = (phi_t[:, 1:][consted[:, :-1]] - daa[consted] * C_p / C_dV) / (1 + daa[consted] * C_V / C_dV) 

    return phi_t</code></pre>
</details>
<div class="desc"><p>Apply the constraints in calculating phi_t</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>phi_t</code></strong></dt>
<dd>Change in value for agents at x at time t from price/aggregate shock (Nz*Na x T matrix)</dd>
<dt><strong><code>consted</code></strong></dt>
<dd>Boolean array indicating indices of agents that are constrained</dd>
<dt><strong><code>C_p</code></strong></dt>
<dd>Derivative of constraint w.r.t. price (either float or Nz*Na x 1 vector for constrained indices only)</dd>
<dt><strong><code>C_V</code></strong></dt>
<dd>Derivative of constraint w.r.t. value (either float or Nz*Na x 1 vector for constrained indices only)</dd>
<dt><strong><code>C_dV</code></strong></dt>
<dd>Derivative of constraint w.r.t. change in value (either float or Nz*Na x 1 vector for constrained indices only)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>phi_t (after adjusting the constrained indices)</p></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="Jacobian_Helpers.J_from_F" href="#Jacobian_Helpers.J_from_F">J_from_F</a></code></li>
<li><code><a title="Jacobian_Helpers.calc_D" href="#Jacobian_Helpers.calc_D">calc_D</a></code></li>
<li><code><a title="Jacobian_Helpers.calc_E" href="#Jacobian_Helpers.calc_E">calc_E</a></code></li>
<li><code><a title="Jacobian_Helpers.calc_F" href="#Jacobian_Helpers.calc_F">calc_F</a></code></li>
<li><code><a title="Jacobian_Helpers.calc_J" href="#Jacobian_Helpers.calc_J">calc_J</a></code></li>
<li><code><a title="Jacobian_Helpers.calc_U" href="#Jacobian_Helpers.calc_U">calc_U</a></code></li>
<li><code><a title="Jacobian_Helpers.calc_dphi_dx" href="#Jacobian_Helpers.calc_dphi_dx">calc_dphi_dx</a></code></li>
<li><code><a title="Jacobian_Helpers.calc_irfs" href="#Jacobian_Helpers.calc_irfs">calc_irfs</a></code></li>
<li><code><a title="Jacobian_Helpers.calc_phi" href="#Jacobian_Helpers.calc_phi">calc_phi</a></code></li>
<li><code><a title="Jacobian_Helpers.calc_phi_HJB" href="#Jacobian_Helpers.calc_phi_HJB">calc_phi_HJB</a></code></li>
<li><code><a title="Jacobian_Helpers.calc_policy_fn" href="#Jacobian_Helpers.calc_policy_fn">calc_policy_fn</a></code></li>
<li><code><a title="Jacobian_Helpers.calc_policy_fn_sum" href="#Jacobian_Helpers.calc_policy_fn_sum">calc_policy_fn_sum</a></code></li>
<li><code><a title="Jacobian_Helpers.check_if_zero" href="#Jacobian_Helpers.check_if_zero">check_if_zero</a></code></li>
<li><code><a title="Jacobian_Helpers.forward_step_matrix" href="#Jacobian_Helpers.forward_step_matrix">forward_step_matrix</a></code></li>
<li><code><a title="Jacobian_Helpers.forward_step_transpose_1d" href="#Jacobian_Helpers.forward_step_transpose_1d">forward_step_transpose_1d</a></code></li>
<li><code><a title="Jacobian_Helpers.forward_step_transpose_1d_dt" href="#Jacobian_Helpers.forward_step_transpose_1d_dt">forward_step_transpose_1d_dt</a></code></li>
<li><code><a title="Jacobian_Helpers.phi_constraints" href="#Jacobian_Helpers.phi_constraints">phi_constraints</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.5</a>.</p>
</footer>
</body>
</html>
